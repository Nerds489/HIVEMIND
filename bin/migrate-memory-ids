#!/bin/bash
#
# Migrate non-conforming mem_* IDs to mem_[a-z0-9]{12} across memory/*.json.
#
# This updates:
# - .id fields
# - any string references equal to a migrated id
#
# Writes a mapping file to: memory/ops/id-migration-map.json
#
# Usage:
#   bin/migrate-memory-ids [--dry-run]

set -euo pipefail

HIVEMIND_ROOT="${HIVEMIND_ROOT:-$(dirname "$(dirname "$(realpath "$0")")")}"
MEMORY_DIR="$HIVEMIND_ROOT/memory"
MAP_FILE="$MEMORY_DIR/ops/id-migration-map.json"
DRY_RUN=0

if [[ "${1:-}" == "--dry-run" ]]; then
  DRY_RUN=1
fi

MEMORY_DIR="$MEMORY_DIR" MAP_FILE="$MAP_FILE" DRY_RUN="$DRY_RUN" python - <<'PY'
import json, os, pathlib, random, re, secrets, sys

root = pathlib.Path(os.environ["MEMORY_DIR"])
map_file = pathlib.Path(os.environ["MAP_FILE"])
dry_run = int(os.environ["DRY_RUN"]) == 1

strict = re.compile(r"^mem_[a-z0-9]{12}$")

def load_json(p: pathlib.Path):
    return json.loads(p.read_text(encoding="utf-8"))

def dump_json(p: pathlib.Path, data):
    p.write_text(json.dumps(data, indent=2, ensure_ascii=False) + "\n", encoding="utf-8")

def walk_collect(obj, ids):
    if isinstance(obj, dict):
        for k, v in obj.items():
            if k == "id" and isinstance(v, str) and v.startswith("mem_") and not strict.match(v):
                ids.add(v)
            walk_collect(v, ids)
    elif isinstance(obj, list):
        for v in obj:
            walk_collect(v, ids)

def walk_replace(obj, mapping):
    if isinstance(obj, dict):
        out = {}
        for k, v in obj.items():
            if k == "id" and isinstance(v, str) and v in mapping:
                out[k] = mapping[v]
            else:
                out[k] = walk_replace(v, mapping)
        return out
    if isinstance(obj, list):
        return [walk_replace(v, mapping) for v in obj]
    if isinstance(obj, str) and obj in mapping:
        return mapping[obj]
    return obj

json_files = [p for p in root.rglob("*.json") if p.is_file()]

# Collect all nonconforming IDs and all existing strict IDs (to avoid collisions).
nonconforming = set()
existing_strict = set()
for p in json_files:
    try:
        data = load_json(p)
    except Exception:
        continue
    # collect strict IDs
    def walk_strict(obj):
        if isinstance(obj, dict):
            v = obj.get("id")
            if isinstance(v, str) and strict.match(v):
                existing_strict.add(v)
            for vv in obj.values():
                walk_strict(vv)
        elif isinstance(obj, list):
            for vv in obj:
                walk_strict(vv)
    walk_strict(data)
    walk_collect(data, nonconforming)

def new_id():
    while True:
        nid = "mem_" + secrets.token_hex(6)  # 12 hex chars; subset of [a-z0-9]
        if nid not in existing_strict:
            existing_strict.add(nid)
            return nid

mapping = {old: new_id() for old in sorted(nonconforming)}

report = {
    "dry_run": dry_run,
    "count": len(mapping),
    "mapping": mapping,
}

if dry_run:
    print(json.dumps(report, indent=2))
    sys.exit(0)

map_file.parent.mkdir(parents=True, exist_ok=True)
dump_json(map_file, report)

changed = 0
for p in json_files:
    try:
        data = load_json(p)
    except Exception:
        continue
    new_data = walk_replace(data, mapping)
    if new_data != data:
        dump_json(p, new_data)
        changed += 1

print(f"migrated_ids={len(mapping)} files_updated={changed} map_file={map_file}")
PY

#!/bin/bash
# Memory operations for HIVEMIND
#
# Notes:
# - Uses existing HIVEMIND memory schemas in memory/long-term/*.json and memory/episodic/events.json
# - Requires jq (available in this environment); errors clearly if missing.

set -euo pipefail

HIVEMIND_ROOT="${HIVEMIND_ROOT:-$(dirname "$(dirname "$(realpath "$0")")")}"
MEMORY_DIR="$HIVEMIND_ROOT/memory"

require_jq() {
  if ! command -v jq >/dev/null 2>&1; then
    echo "Error: jq is required for memory-ops." >&2
    exit 1
  fi
}

ensure_file() {
  local file="$1"
  local init_json="$2"
  mkdir -p "$(dirname "$file")"
  [[ -f "$file" ]] || printf '%s\n' "$init_json" > "$file"
}

gen_id() {
  echo "mem_$(tr -dc 'a-z0-9' </dev/urandom | fold -w 12 | head -n 1)"
}

now_iso() {
  date -Iseconds
}

store() {
  require_jq

  local type="${1:-}"
  local content="${2:-}"
  shift 2 || true
  local tags=("$@")

  if [[ -z "$type" || -z "$content" ]]; then
    echo "Usage: memory-ops store <type> <content> [tags...]" >&2
    exit 1
  fi

  local id timestamp
  id="$(gen_id)"
  timestamp="$(now_iso)"

  local tags_json
  tags_json="$(printf '%s\n' "${tags[@]:-}" | jq -R . | jq -s .)"

  case "$type" in
    fact|pattern|anti_pattern)
      local file="$MEMORY_DIR/long-term/learnings.json"
      ensure_file "$file" '{"version":"1.0","entries":[]}'
      local entry
      entry="$(jq -n \
        --arg id "$id" \
        --arg type "$type" \
        --arg content "$content" \
        --arg created "$timestamp" \
        --argjson tags "$tags_json" \
        '{id:$id,type:$type,content:$content,tags:$tags,confidence:0.5,created_at:$created,updated_at:$created,access_count:0,source:"observation"}')"
      jq --argjson entry "$entry" '.entries += [$entry]' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
      ;;

    preference|rule)
      local file="$MEMORY_DIR/long-term/preferences.json"
      ensure_file "$file" '{"version":"1.0","user_preferences":{"communication_style":null,"detail_level":"standard","code_style":{"language":null,"indentation":"spaces","indent_size":2},"rules":[]}}'
      local entry
      entry="$(jq -n \
        --arg id "$id" \
        --arg type "$type" \
        --arg content "$content" \
        --arg created "$timestamp" \
        --argjson tags "$tags_json" \
        '{id:$id,type:$type,content:$content,tags:$tags,confidence:0.5,created_at:$created,updated_at:$created,source:"observation"}')"
      jq --argjson entry "$entry" '.user_preferences.rules += [$entry]' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
      ;;

    decision)
      local file="$MEMORY_DIR/long-term/decisions.json"
      ensure_file "$file" '{"version":"1.0","decisions":[]}'
      local entry
      entry="$(jq -n \
        --arg id "$id" \
        --arg type "$type" \
        --arg content "$content" \
        --arg created "$timestamp" \
        --argjson tags "$tags_json" \
        '{id:$id,type:$type,content:$content,tags:$tags,confidence:0.5,created_at:$created,updated_at:$created,source:"observation"}')"
      jq --argjson entry "$entry" '.decisions += [$entry]' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
      ;;

    project|tech_stack|tool)
      local file="$MEMORY_DIR/long-term/project.json"
      ensure_file "$file" '{"version":"1.0","project":{"name":null,"description":null,"tech_stack":[],"tools":[],"conventions":[],"architecture":null}}'
      case "$type" in
        tech_stack)
          jq --arg v "$content" '(.project.tech_stack) |= (if index($v) then . else . + [$v] end)' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
          ;;
        tool)
          jq --arg v "$content" '(.project.tools) |= (if index($v) then . else . + [$v] end)' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
          ;;
        project)
          jq --arg v "$content" '(.project.conventions) |= (if index($v) then . else . + [$v] end)' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
          ;;
      esac
      ;;

    event)
      local file="$MEMORY_DIR/episodic/events.json"
      ensure_file "$file" '{"version":"1.0","events":[]}'
      local entry
      entry="$(jq -n \
        --arg id "$id" \
        --arg type "$type" \
        --arg content "$content" \
        --arg created "$timestamp" \
        --argjson tags "$tags_json" \
        '{id:$id,type:$type,content:$content,tags:$tags,confidence:0.5,created_at:$created,source:"observation"}')"
      jq --argjson entry "$entry" '.events += [$entry]' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
      ;;

    *)
      echo "Unknown type '$type' (using learnings.json)" >&2
      store fact "$content" "${tags[@]:-}"
      return 0
      ;;
  esac

  echo "$id"
}

recall() {
  require_jq
  local query="${1:-}"
  if [[ -z "$query" ]]; then
    echo "Usage: memory-ops recall <query>" >&2
    exit 1
  fi

  local q
  q="$(printf '%s' "$query" | tr '[:upper:]' '[:lower:]')"

  # learnings
  if [[ -f "$MEMORY_DIR/long-term/learnings.json" ]]; then
    jq -r --arg q "$q" '.entries[]? | select((.content // "" | ascii_downcase | contains($q))) | "\(.id): \(.content)"' \
      "$MEMORY_DIR/long-term/learnings.json" 2>/dev/null || true
  fi

  # preferences rules
  if [[ -f "$MEMORY_DIR/long-term/preferences.json" ]]; then
    jq -r --arg q "$q" '.user_preferences.rules[]? | select((.content // "" | ascii_downcase | contains($q))) | "\(.id): \(.content)"' \
      "$MEMORY_DIR/long-term/preferences.json" 2>/dev/null || true
  fi

  # decisions
  if [[ -f "$MEMORY_DIR/long-term/decisions.json" ]]; then
    jq -r --arg q "$q" '.decisions[]? | select((.content // "" | ascii_downcase | contains($q))) | "\(.id): \(.content)"' \
      "$MEMORY_DIR/long-term/decisions.json" 2>/dev/null || true
  fi

  # project arrays (string match)
  if [[ -f "$MEMORY_DIR/long-term/project.json" ]]; then
    jq -r --arg q "$q" '
      (.project.tech_stack[]? | select((. | ascii_downcase | contains($q))) | "tech_stack: \(.)"),
      (.project.tools[]? | select((. | ascii_downcase | contains($q))) | "tool: \(.)"),
      (.project.conventions[]? | select((. | ascii_downcase | contains($q))) | "project: \(.)")
    ' "$MEMORY_DIR/long-term/project.json" 2>/dev/null || true
  fi

  # events
  if [[ -f "$MEMORY_DIR/episodic/events.json" ]]; then
    jq -r --arg q "$q" '.events[]? | select((.content // "" | ascii_downcase | contains($q))) | "\(.id): \(.content)"' \
      "$MEMORY_DIR/episodic/events.json" 2>/dev/null || true
  fi
}

list_memories() {
  require_jq
  local scope="${1:-all}"

  case "$scope" in
    all|long-term)
      [[ -f "$MEMORY_DIR/long-term/learnings.json" ]] && jq -r '.entries[]? | "\(.id)\t\(.type)\t\(.content)"' "$MEMORY_DIR/long-term/learnings.json" 2>/dev/null || true
      [[ -f "$MEMORY_DIR/long-term/preferences.json" ]] && jq -r '.user_preferences.rules[]? | "\(.id)\t\(.type)\t\(.content)"' "$MEMORY_DIR/long-term/preferences.json" 2>/dev/null || true
      [[ -f "$MEMORY_DIR/long-term/decisions.json" ]] && jq -r '.decisions[]? | "\(.id)\t\(.type)\t\(.content)"' "$MEMORY_DIR/long-term/decisions.json" 2>/dev/null || true
      ;;
    events|episodic)
      [[ -f "$MEMORY_DIR/episodic/events.json" ]] && jq -r '.events[]? | "\(.id)\t\(.type)\t\(.content)"' "$MEMORY_DIR/episodic/events.json" 2>/dev/null || true
      ;;
    *)
      echo "Usage: memory-ops list [all|long-term|events]" >&2
      exit 1
      ;;
  esac
}

mutate_confidence() {
  require_jq
  local op="$1"
  local id="${2:-}"
  if [[ -z "$id" ]]; then
    echo "Usage: memory-ops ${op} <id>" >&2
    exit 1
  fi

  # op: boost (+0.2), decay (-0.1)
  local delta
  case "$op" in
    boost) delta="0.2" ;;
    decay) delta="-0.1" ;;
    *) echo "Internal error: unknown op $op" >&2; exit 1 ;;
  esac

  local updated=1

  # learnings
  local f="$MEMORY_DIR/long-term/learnings.json"
  if [[ -f "$f" ]] && jq -e --arg id "$id" '.entries[]? | select(.id == $id)' "$f" >/dev/null 2>&1; then
    jq --arg id "$id" --argjson delta "$delta" '
      (.entries[] | select(.id == $id) | .confidence) |= ((. + $delta) | if . > 1 then 1 elif . < 0 then 0 else . end)
    ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
    updated=0
  fi

  # preferences rules
  f="$MEMORY_DIR/long-term/preferences.json"
  if [[ -f "$f" ]] && jq -e --arg id "$id" '.user_preferences.rules[]? | select(.id == $id)' "$f" >/dev/null 2>&1; then
    jq --arg id "$id" --argjson delta "$delta" '
      (.user_preferences.rules[] | select(.id == $id) | .confidence) |= ((. + $delta) | if . > 1 then 1 elif . < 0 then 0 else . end)
    ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
    updated=0
  fi

  # decisions
  f="$MEMORY_DIR/long-term/decisions.json"
  if [[ -f "$f" ]] && jq -e --arg id "$id" '.decisions[]? | select(.id == $id)' "$f" >/dev/null 2>&1; then
    jq --arg id "$id" --argjson delta "$delta" '
      (.decisions[] | select(.id == $id) | .confidence) |= ((. + $delta) | if . > 1 then 1 elif . < 0 then 0 else . end)
    ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
    updated=0
  fi

  # events
  f="$MEMORY_DIR/episodic/events.json"
  if [[ -f "$f" ]] && jq -e --arg id "$id" '.events[]? | select(.id == $id)' "$f" >/dev/null 2>&1; then
    jq --arg id "$id" --argjson delta "$delta" '
      (.events[] | select(.id == $id) | .confidence) |= ((. + $delta) | if . > 1 then 1 elif . < 0 then 0 else . end)
    ' "$f" > "$f.tmp" && mv "$f.tmp" "$f"
    updated=0
  fi

  return "$updated"
}

boost() { mutate_confidence boost "$@"; }
decay() { mutate_confidence decay "$@"; }

case "${1:-}" in
  store) shift; store "$@" ;;
  recall) shift; recall "$@" ;;
  list) shift; list_memories "$@" ;;
  boost) shift; boost "$@" ;;
  decay) shift; decay "$@" ;;
  *)
    echo "Usage: memory-ops {store|recall|list|boost|decay} [args]" >&2
    exit 1
    ;;
esac

#!/bin/bash
#
# Generate an implementation/validation report for the HIVEMIND repository.
#
# Output:
#   reports/HIVEMIND-IMPLEMENTATION-REPORT.md
#
# Usage:
#   bin/audit-hivemind

set -euo pipefail

HIVEMIND_ROOT="${HIVEMIND_ROOT:-$(dirname "$(dirname "$(realpath "$0")")")}"
OUT_DIR="$HIVEMIND_ROOT/reports"
OUT_FILE="$OUT_DIR/HIVEMIND-IMPLEMENTATION-REPORT.md"

mkdir -p "$OUT_DIR"

HIVEMIND_ROOT="$HIVEMIND_ROOT" OUT_FILE="$OUT_FILE" python - <<'PY'
from __future__ import annotations

import os
import pathlib
import subprocess
from datetime import datetime, timezone

ROOT = pathlib.Path(os.environ["HIVEMIND_ROOT"])
OUT_FILE = pathlib.Path(os.environ["OUT_FILE"])


def sh(cmd: list[str]) -> str:
    return subprocess.check_output(cmd, cwd=ROOT, text=True)


def git_porcelain() -> dict[str, str]:
    try:
        out = sh(["git", "status", "--porcelain"])
    except Exception:
        return {}
    status: dict[str, str] = {}
    for line in out.splitlines():
        if not line.strip():
            continue
        code = line[:2]
        path = line[3:]
        if " -> " in path:
            path = path.split(" -> ", 1)[1]
        status[path] = "CREATED" if code.strip() == "??" else "MODIFIED"
    return status


def line_count(p: pathlib.Path) -> int:
    try:
        return p.read_text(encoding="utf-8", errors="ignore").count("\n") + 1
    except Exception:
        return 0


required_paths = [
    "CLAUDE.md",
    "CODEX.md",
    "HIVEMIND.md",
    "QUICKSTART.md",
    "BOOTSTRAP.md",
    "INDEX.md",
    "AGENTS.md",
    "IDENTITY.md",
    "SYSTEM-CHECK.md",
    ".claude/commands/hivemind.md",
    ".claude/commands/architect.md",
    ".claude/commands/dev.md",
    ".claude/commands/sec.md",
    ".claude/commands/infra.md",
    ".claude/commands/qa.md",
    ".claude/commands/pentest.md",
    ".claude/commands/reviewer.md",
    ".claude/commands/sre.md",
    ".claude/commands/sdlc.md",
    ".claude/commands/incident.md",
    ".codex/trigger.md",
    "orchestration/COORDINATOR.md",
    "orchestration/task-router.md",
    "orchestration/context-manager.md",
    "runtime/ROUTER.md",
    "runtime/OUTPUT-FILTER.md",
    "runtime/FILTER.md",
    "runtime/VOICE-RULES.md",
    "runtime/PROJECT-DETECTOR.md",
    "runtime/PREFLIGHT.md",
    "runtime/POSTTASK.md",
    "runtime/CONTROLLER.md",
    "runtime/PREDICTOR.md",
    "runtime/SELF-IMPROVE.md",
    "protocols/messages.md",
    "protocols/escalation.md",
    "protocols/handoffs.md",
    "protocols/security-gates.md",
    "protocols/QUALITY-GATES.md",
    "workflows/full-sdlc.md",
    "workflows/security-assessment.md",
    "workflows/incident-response.md",
    "workflows/code-review.md",
    "workflows/infrastructure-deploy.md",
    "workflows/compliance-audit.md",
    "teams/development.md",
    "teams/security.md",
    "teams/infrastructure.md",
    "teams/qa.md",
    "templates/security-report.md",
    "templates/architecture-decision-record.md",
    "templates/incident-report.md",
    "templates/code-review-findings.md",
    "templates/test-results.md",
    "templates/deployment-checklist.md",
    "templates/change-request.md",
    "templates/compliance-checklist.md",
    "templates/performance-baseline.md",
    "config/agents.json",
    "config/agents.yaml",
    "config/routing.json",
    "config/routing.yaml",
    "config/engines.yaml",
    "config/hivemind.yaml",
    "config/settings.json",
    "config/README.md",
    "config/docs/globals.md",
    "config/docs/tool-matrix.md",
    "config/docs/output-standards.md",
    "memory/README.md",
    "memory/MEMORY.md",
    "memory/MEMORY-PROTOCOL.md",
    "memory/ENGINE.md",
    "memory/TRIGGERS.md",
    "memory/QUERY.md",
    "memory/COMMANDS.md",
    "memory/IMPLEMENTATION-CHECKLIST.md",
    "memory/schemas/memory-entry.schema.json",
    "memory/schemas/index.schema.json",
    "memory/schemas/query.schema.json",
    "memory/schemas/context-package.schema.json",
    "memory/schemas/factual.json",
    "memory/schemas/procedural.json",
    "memory/schemas/episodic.json",
    "memory/schemas/semantic.json",
    "memory/schemas/working.json",
    "memory/long-term/learnings.json",
    "memory/long-term/preferences.json",
    "memory/long-term/project.json",
    "memory/long-term/user-profile.json",
    "memory/long-term/decisions.json",
    "memory/episodic/events.json",
    "bin/hm",
    "bin/orchestrate",
    "bin/spawn-agent",
    "bin/query-agent",
    "bin/wait-agent",
    "bin/list-agents",
    "bin/kill-agents",
    "bin/memory-ops",
    "bin/test-hivemind",
    "core/orchestrator.sh",
    "core/router.sh",
    "core/spawner.sh",
    "core/synthesizer.sh",
    "engines/engine.sh",
    "engines/claude-code.sh",
    "engines/codex.sh",
    "comms/BUS.md",
    "comms/MESSAGE-BUS.md",
    "comms/SPAWN.md",
    "comms/SPAWN-PROTOCOL.md",
    "comms/TEAMS.md",
    "comms/TEAM-COORDINATION.md",
    "hivemind",
    "install.sh",
]


missing = [p for p in required_paths if not (ROOT / p).exists()]
porc = git_porcelain()
all_files = sorted([p for p in ROOT.rglob("*") if p.is_file() and ".git" not in p.parts])

claude_lines = line_count(ROOT / "CLAUDE.md")
coord_lines = line_count(ROOT / "orchestration/COORDINATOR.md")

ts = datetime.now(timezone.utc).isoformat()

lines: list[str] = []
lines.append("# HIVEMIND Implementation Report")
lines.append("")
lines.append(f"- Generated: {ts}")
lines.append(f"- Repo: `{ROOT}`")
lines.append("")

lines.append("## Summary")
lines.append(f"- Files audited: {len(all_files)}")
lines.append(f"- Required paths missing: {len(missing)}")
lines.append(f"- Git changes detected: {len(porc)}")
lines.append("")

lines.append("## Critical Minimums")
lines.append(f"- `CLAUDE.md` lines: {claude_lines} ({'OK' if claude_lines >= 500 else 'NEEDS ATTENTION'})")
lines.append(f"- `orchestration/COORDINATOR.md` lines: {coord_lines} ({'OK' if coord_lines >= 500 else 'NEEDS ATTENTION'})")
lines.append("")

if missing:
    lines.append("## Missing Required Paths")
    for m in missing:
        lines.append(f"- `{m}`")
    lines.append("")

lines.append("## File Manifest")
lines.append("| Path | Lines | Status |")
lines.append("|------|------:|--------|")
for p in all_files:
    rel = str(p.relative_to(ROOT))
    status = porc.get(rel, "OK")
    lines.append(f"| `{rel}` | {line_count(p)} | {status} |")

OUT_FILE.write_text("\n".join(lines) + "\n", encoding="utf-8")
print(str(OUT_FILE))
PY

echo "Wrote report: $OUT_FILE" >&2

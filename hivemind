#!/usr/bin/env bash
# ============================================================
# HIVEMIND - Unified Orchestration CLI
# Version: 1.0.0
# ============================================================

set -euo pipefail
IFS=$' \t\n'

trap 'printf "\n"; exit 130' INT

VERSION="1.0.0"
VERSION_LABEL="v1.0.0 GENESIS"
TAGLINE="24 Agents • 4 Teams • 1 Unified Intelligence"

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/hivemind"
CONFIG_FILE="$CONFIG_DIR/config.json"
HISTORY_FILE="$CONFIG_DIR/history"

CLAUDE_MODEL_DEFAULT="claude-sonnet-4-20250514"
OPENAI_MODEL_DEFAULT="gpt-4o"
ENGINE_PREFERRED=""
ENGINE_FALLBACK=""

SYSTEM_PROMPT=$(cat <<'PROMPT'
You are HIVEMIND - a unified neural orchestration system. You speak as ONE mind, ONE voice, ONE expert. You coordinate 24 specialized agents across 4 teams internally, but the user only sees unified responses. Never reference internal agents or teams in your responses. Never say "let me check with" or "the team suggests". Just provide expert answers directly.
PROMPT
)

ACTIVE_ENGINE=""
ENGINE_MODEL=""
ENGINE_OVERRIDE=""
MODEL_OVERRIDE=""
COLOR_ENABLED="true"
COMPACT_MODE="false"

MAG=""; PNK=""; PUR=""; BLU=""; CYN=""; WHT=""; DIM=""; RST=""
RED=""; GRN=""; YLW=""; BLU2=""; CYN2=""

TEAMS=("DEV" "SEC" "INF" "QA")
TEAM_COLORS=()
TEAM_AGENT_IDS=(
  "DEV-001 DEV-002 DEV-003 DEV-004 DEV-005 DEV-006"
  "SEC-001 SEC-002 SEC-003 SEC-004 SEC-005 SEC-006"
  "INF-001 INF-002 INF-003 INF-004 INF-005 INF-006"
  "QA-001 QA-002 QA-003 QA-004 QA-005 QA-006"
)
TEAM_AGENT_LABELS=(
  "Architect|Backend Dev|Frontend Dev|Reviewer|Writer|DevOps"
  "Security Arch|Pentester|Malware|Wireless|Compliance|Incident"
  "Infra Arch|SysAdmin|Network|DBA|SRE|Automation"
  "QA Arch|Test Auto|Perf Test|Sec Test|Manual QA|Test Data"
)

ALL_AGENT_IDS=()

declare -A AGENT_STATUS

declare -A AGENT_TASK

supports_color() {
  [[ -t 1 ]] || return 1
  local colors
  colors=$(tput colors 2>/dev/null || echo 0)
  [[ "$colors" -ge 256 ]]
}

init_colors() {
  if [[ -n "${NO_COLOR:-}" ]]; then
    COLOR_ENABLED="false"
  fi

  if [[ "$COLOR_ENABLED" == "true" ]] && supports_color; then
    MAG=$'\033[38;5;201m'
    PNK=$'\033[38;5;199m'
    PUR=$'\033[38;5;165m'
    BLU=$'\033[38;5;135m'
    CYN=$'\033[38;5;51m'
    WHT=$'\033[1;97m'
    DIM=$'\033[2m'
    RST=$'\033[0m'

    RED=$'\033[1;31m'
    GRN=$'\033[1;32m'
    YLW=$'\033[1;33m'
    BLU2=$'\033[1;34m'
    CYN2=$'\033[1;36m'
  else
    MAG=""; PNK=""; PUR=""; BLU=""; CYN=""; WHT=""; DIM=""; RST=""
    RED=""; GRN=""; YLW=""; BLU2=""; CYN2=""
  fi

  TEAM_COLORS=("$CYN2" "$RED" "$GRN" "$YLW")
}

term_cols() {
  local cols
  cols=$(tput cols 2>/dev/null || echo 80)
  if [[ -z "$cols" || "$cols" -lt 60 ]]; then
    echo 80
  else
    echo "$cols"
  fi
}

load_config() {
  if [[ -f "$CONFIG_FILE" ]] && command -v jq >/dev/null 2>&1; then
    local colors
    local compact
    local claude_model
    local openai_model

    ENGINE_PREFERRED=$(jq -r '.engine.preferred // empty' "$CONFIG_FILE")
    ENGINE_FALLBACK=$(jq -r '.engine.fallback // empty' "$CONFIG_FILE")

    claude_model=$(jq -r '.engine.model.claude // empty' "$CONFIG_FILE")
    openai_model=$(jq -r '.engine.model.openai // empty' "$CONFIG_FILE")
    if [[ -n "$claude_model" && "$claude_model" != "null" ]]; then
      CLAUDE_MODEL_DEFAULT="$claude_model"
    fi
    if [[ -n "$openai_model" && "$openai_model" != "null" ]]; then
      OPENAI_MODEL_DEFAULT="$openai_model"
    fi

    colors=$(jq -r '.display.colors // "true"' "$CONFIG_FILE")
    compact=$(jq -r '.display.compact_mode // "false"' "$CONFIG_FILE")

    if [[ "$colors" == "false" ]]; then
      COLOR_ENABLED="false"
    fi
    if [[ "$compact" == "true" ]]; then
      COMPACT_MODE="true"
    fi
  fi
}

show_banner() {
  if [[ -t 1 ]]; then
    clear || printf '\033c'
  fi

  local term_width
  local banner_width
  local pad
  local spacer

  term_width=$(term_cols)
  banner_width=74
  pad=$(( (term_width - banner_width) / 2 ))
  if (( pad < 0 )); then
    pad=0
  fi
  spacer=$(printf '%*s' "$pad" '')

  printf '\n'
  printf '%b\n' "${spacer}${MAG}╔══════════════════════════════════════════════════════════════════════╗${RST}"
  printf '%b\n' "${spacer}${MAG}║${RST}  ${MAG}██╗  ██╗${CYN}██╗${MAG}██╗   ██╗${CYN}███████╗${MAG}███╗   ███╗${CYN}██╗${MAG}███╗   ██╗${CYN}██████╗${RST}   ${MAG}║${RST}"
  printf '%b\n' "${spacer}${PNK}║${RST}  ${MAG}██║  ██║${CYN}██║${MAG}██║   ██║${CYN}██╔════╝${MAG}████╗ ████║${CYN}██║${MAG}████╗  ██║${CYN}██╔══██╗${RST}  ${PNK}║${RST}"
  printf '%b\n' "${spacer}${PUR}║${RST}  ${MAG}███████║${CYN}██║${MAG}██║   ██║${CYN}█████╗  ${MAG}██╔████╔██║${CYN}██║${MAG}██╔██╗ ██║${CYN}██║  ██║${RST}  ${PUR}║${RST}"
  printf '%b\n' "${spacer}${BLU}║${RST}  ${MAG}██╔══██║${CYN}██║${MAG}╚██╗ ██╔╝${CYN}██╔══╝  ${MAG}██║╚██╔╝██║${CYN}██║${MAG}██║╚██╗██║${CYN}██║  ██║${RST}  ${BLU}║${RST}"
  printf '%b\n' "${spacer}${CYN}║${RST}  ${MAG}██║  ██║${CYN}██║${MAG} ╚████╔╝ ${CYN}███████╗${MAG}██║ ╚═╝ ██║${CYN}██║${MAG}██║ ╚████║${CYN}██████╔╝${RST}  ${CYN}║${RST}"
  printf '%b\n' "${spacer}${CYN}║${RST}  ${MAG}╚═╝  ╚═╝${CYN}╚═╝${MAG}  ╚═══╝  ${CYN}╚══════╝${MAG}╚═╝     ╚═╝${CYN}╚═╝${MAG}╚═╝  ╚═══╝${CYN}╚═════╝${RST}   ${CYN}║${RST}"
  printf '%b\n' "${spacer}${CYN}║${RST}                                                                      ${CYN}║${RST}"
  printf '%b\n' "${spacer}${CYN}║${RST}        ${WHT}24 Agents${RST} ${DIM}•${RST} ${WHT}4 Teams${RST} ${DIM}•${RST} ${WHT}1 Unified Intelligence${RST}              ${CYN}║${RST}"
  printf '%b\n' "${spacer}${CYN}╚══════════════════════════════════════════════════════════════════════╝${RST}"
  printf '%b\n' "${spacer}                         ${DIM}${VERSION_LABEL}${RST}"
  printf '\n'
}

init_agents() {
  ALL_AGENT_IDS=()
  for ids in "${TEAM_AGENT_IDS[@]}"; do
    for id in $ids; do
      ALL_AGENT_IDS+=("$id")
    done
  done

  for id in "${ALL_AGENT_IDS[@]}"; do
    AGENT_STATUS["$id"]="standby"
    AGENT_TASK["$id"]="—"
  done
}

reset_agent_status() {
  for id in "${ALL_AGENT_IDS[@]}"; do
    AGENT_STATUS["$id"]="standby"
    AGENT_TASK["$id"]="—"
  done
}

set_agent() {
  local id="$1"
  local status="$2"
  local task="$3"
  AGENT_STATUS["$id"]="$status"
  AGENT_TASK["$id"]="$task"
}

activate_agents() {
  local request
  request="${1,,}"

  reset_agent_status

  if [[ "$request" =~ (code|develop|build|api|backend|frontend|implement|create|function|class) ]]; then
    set_agent "DEV-001" "active" "Analyzing requirements"

    if [[ "$request" =~ (backend|api|server|database|endpoint) ]]; then
      set_agent "DEV-002" "active" "Backend implementation"
    fi

    if [[ "$request" =~ (frontend|ui|interface|component|react|vue) ]]; then
      set_agent "DEV-003" "active" "UI development"
    fi
  fi

  if [[ "$request" =~ (security|secure|vulnerability|pentest|audit|exploit|attack|hack) ]]; then
    set_agent "SEC-001" "active" "Security analysis"

    if [[ "$request" =~ (pentest|exploit|vulnerability|attack) ]]; then
      set_agent "SEC-002" "active" "Vulnerability assessment"
    fi
  fi

  if [[ "$request" =~ (infrastructure|deploy|server|kubernetes|docker|cloud|aws|terraform) ]]; then
    set_agent "INF-001" "active" "Infrastructure design"

    if [[ "$request" =~ (kubernetes|docker|container) ]]; then
      set_agent "INF-006" "active" "Container orchestration"
    fi
  fi

  if [[ "$request" =~ (test|quality|qa|coverage|regression|performance) ]]; then
    set_agent "QA-001" "active" "Test planning"

    if [[ "$request" =~ (performance|load|stress) ]]; then
      set_agent "QA-003" "active" "Performance analysis"
    fi
  fi
}

status_icon() {
  local status="$1"
  case "$status" in
    active)
      printf '%s●%s' "$GRN" "$RST"
      ;;
    working)
      printf '%s◐%s' "$YLW" "$RST"
      ;;
    waiting)
      printf '%s◌%s' "$CYN2" "$RST"
      ;;
    *)
      printf '%s○%s' "$DIM" "$RST"
      ;;
  esac
}

show_agent_status_compact() {
  local parts=()
  local any=false

  for i in "${!TEAMS[@]}"; do
    local team="${TEAMS[$i]}"
    local ids_str="${TEAM_AGENT_IDS[$i]}"
    local labels_str="${TEAM_AGENT_LABELS[$i]}"
    local names=()
    local ids=()

    IFS=' ' read -r -a ids <<< "$ids_str"
    IFS='|' read -r -a names <<< "$labels_str"

    local active_names=()
    for idx in "${!ids[@]}"; do
      local id="${ids[$idx]}"
      local status="${AGENT_STATUS[$id]}"
      if [[ "$status" == "active" || "$status" == "working" || "$status" == "waiting" ]]; then
        active_names+=("${names[$idx]}")
      fi
    done

    if ((${#active_names[@]} > 0)); then
      any=true
      local joined
      joined=$(IFS=','; echo "${active_names[*]}")
      parts+=("${team}[${joined}]")
    fi
  done

  if [[ "$any" == "true" ]]; then
    printf '%b\n' "${MAG}◈${RST} ${WHT}ACTIVE:${RST} ${parts[*]} ${DIM}|${RST} Processing..."
  else
    printf '%b\n' "${MAG}◈${RST} ${WHT}ACTIVE:${RST} none ${DIM}|${RST} Processing..."
  fi
}

show_agent_status() {
  if [[ "$COMPACT_MODE" == "true" ]]; then
    show_agent_status_compact
    return
  fi

  printf '\n'
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '%b\n' " ${MAG}◈${RST} ${WHT}HIVEMIND PROCESSING${RST}"
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"

  local any_active=false

  for i in "${!TEAMS[@]}"; do
    local team="${TEAMS[$i]}"
    local color="${TEAM_COLORS[$i]}"
    local ids_str="${TEAM_AGENT_IDS[$i]}"
    local labels_str="${TEAM_AGENT_LABELS[$i]}"
    local ids=()
    local names=()

    IFS=' ' read -r -a ids <<< "$ids_str"
    IFS='|' read -r -a names <<< "$labels_str"

    local team_active=false
    for idx in "${!ids[@]}"; do
      local id="${ids[$idx]}"
      local status="${AGENT_STATUS[$id]}"
      if [[ "$status" == "active" || "$status" == "working" || "$status" == "waiting" ]]; then
        team_active=true
        any_active=true
        break
      fi
    done

    if [[ "$team_active" == "true" ]]; then
      local first=true
      for idx in "${!ids[@]}"; do
        local id="${ids[$idx]}"
        local name="${names[$idx]}"
        local status="${AGENT_STATUS[$id]}"
        local task="${AGENT_TASK[$id]}"
        if [[ "$status" == "active" || "$status" == "working" || "$status" == "waiting" ]]; then
          local icon
          icon=$(status_icon "$status")
          if [[ "$first" == "true" ]]; then
            printf ' %b%-3s%b │ %b %-13s │ %s\n' "$color" "$team" "$RST" "$icon" "$name" "$task"
            first=false
          else
            printf '     │ %b %-13s │ %s\n' "$icon" "$name" "$task"
          fi
        fi
      done
    fi
  done

  if [[ "$any_active" == "false" ]]; then
    printf ' %bNo active agents%b\n' "$DIM" "$RST"
  fi

  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '\n'
}

show_all_agents() {
  printf '\n'
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '%b\n' " ${MAG}◈${RST} ${WHT}HIVEMIND STATUS${RST}"
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"

  for i in "${!TEAMS[@]}"; do
    local team="${TEAMS[$i]}"
    local color="${TEAM_COLORS[$i]}"
    local ids_str="${TEAM_AGENT_IDS[$i]}"
    local labels_str="${TEAM_AGENT_LABELS[$i]}"
    local ids=()
    local names=()

    IFS=' ' read -r -a ids <<< "$ids_str"
    IFS='|' read -r -a names <<< "$labels_str"

    local first=true
    for idx in "${!ids[@]}"; do
      local id="${ids[$idx]}"
      local name="${names[$idx]}"
      local status="${AGENT_STATUS[$id]}"
      local task="${AGENT_TASK[$id]}"
      local icon
      icon=$(status_icon "$status")

      if [[ "$first" == "true" ]]; then
        printf ' %b%-3s%b │ %b %-13s │ %s\n' "$color" "$team" "$RST" "$icon" "$name" "$task"
        first=false
      else
        printf '     │ %b %-13s │ %s\n' "$icon" "$name" "$task"
      fi
    done
  done

  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '\n'
}

filter_response() {
  local raw="$1"
  local filtered

  filtered=$(printf '%s\n' "$raw" | sed \
    -e '/<thinking>/,/<\/thinking>/d' \
    -e '/<antThinking>/,/<\/antThinking>/d' \
    -e '/^OpenAI Codex/d' \
    -e '/^Codex CLI/d' \
    -e '/^Claude Code/d' \
    -e '/^Tip:/d' \
    -e '/^Model:/d' \
    -e '/^I am thinking about/d' \
    -e '/^Let me analyze/d')

  filtered=$(printf '%s\n' "$filtered" | sed -e 's/^[[:space:]]\+$//g' -e '/./,$!d')

  printf '%s\n' "$filtered"
}

engine_available() {
  case "$1" in
    claude)
      command -v claude >/dev/null 2>&1
      ;;
    codex)
      command -v codex >/dev/null 2>&1
      ;;
    anthropic-api)
      [[ -n "${ANTHROPIC_API_KEY:-}" ]]
      ;;
    openai-api)
      [[ -n "${OPENAI_API_KEY:-}" ]]
      ;;
    *)
      return 1
      ;;
  esac
}

detect_engine() {
  if [[ -n "$ENGINE_OVERRIDE" ]]; then
    if engine_available "$ENGINE_OVERRIDE"; then
      ACTIVE_ENGINE="$ENGINE_OVERRIDE"
      return 0
    fi
    ACTIVE_ENGINE=""
    return 1
  fi

  if [[ -n "$ENGINE_PREFERRED" ]] && engine_available "$ENGINE_PREFERRED"; then
    ACTIVE_ENGINE="$ENGINE_PREFERRED"
  elif [[ -n "$ENGINE_FALLBACK" ]] && engine_available "$ENGINE_FALLBACK"; then
    ACTIVE_ENGINE="$ENGINE_FALLBACK"
  elif engine_available "claude"; then
    ACTIVE_ENGINE="claude"
  elif engine_available "codex"; then
    ACTIVE_ENGINE="codex"
  elif engine_available "anthropic-api"; then
    ACTIVE_ENGINE="anthropic-api"
  elif engine_available "openai-api"; then
    ACTIVE_ENGINE="openai-api"
  else
    ACTIVE_ENGINE=""
  fi
}

resolve_engine_model() {
  case "$ACTIVE_ENGINE" in
    claude|anthropic-api)
      echo "${MODEL_OVERRIDE:-$CLAUDE_MODEL_DEFAULT}"
      ;;
    codex|openai-api)
      echo "${MODEL_OVERRIDE:-$OPENAI_MODEL_DEFAULT}"
      ;;
    *)
      echo "${MODEL_OVERRIDE:-}"
      ;;
  esac
}

show_engine_info() {
  local model
  model="$ENGINE_MODEL"
  if [[ -z "$model" ]]; then
    model="default"
  fi
  printf '%b\n' "${WHT}Engine:${RST} ${BLU2}${ACTIVE_ENGINE:-none}${RST} ${DIM}|${RST} ${WHT}Model:${RST} ${BLU2}${model}${RST}"
}

show_no_engine() {
  printf '\n'
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '%b\n' " ${RED}✗${RST} ${WHT}No AI engine detected${RST}"
  printf '\n'
  printf '%b\n' " Install one of:"
  printf '%b\n' "   • Claude Code CLI: npm install -g @anthropic-ai/claude-code"
  printf '%b\n' "   • OpenAI Codex:    pip install openai-codex"
  printf '%b\n' "   • Set API key:     export ANTHROPIC_API_KEY=..."
  printf '%b\n' "                      export OPENAI_API_KEY=..."
  printf '\n'
  printf '%b\n' " Then run: hivemind --setup"
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '\n'
}

show_engine_error() {
  local message="$1"
  printf '\n'
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '%b\n' " ${RED}✗${RST} ${WHT}Engine error:${RST} ${message}"
  printf '\n'
  printf '%b\n' " Try:"
  printf '%b\n' "   • Check your API key is valid"
  printf '%b\n' "   • Check network connectivity"
  printf '%b\n' "   • Run: hivemind --setup"
  printf '%b\n' "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${RST}"
  printf '\n'
}

call_anthropic_api() {
  local system_prompt="$1"
  local user_message="$2"

  if ! command -v jq >/dev/null 2>&1; then
    printf '%s\n' "jq is required for API calls."
    return 1
  fi

  curl -s https://api.anthropic.com/v1/messages \
    -H "Content-Type: application/json" \
    -H "x-api-key: $ANTHROPIC_API_KEY" \
    -H "anthropic-version: 2023-06-01" \
    -d "{\n      \"model\": \"$ENGINE_MODEL\",\n      \"max_tokens\": 8192,\n      \"system\": $(printf '%s' "$system_prompt" | jq -Rs .),\n      \"messages\": [{\n        \"role\": \"user\",\n        \"content\": $(printf '%s' "$user_message" | jq -Rs .)\n      }]\n    }" | jq -r '.content[0].text'
}

call_openai_api() {
  local system_prompt="$1"
  local user_message="$2"

  if ! command -v jq >/dev/null 2>&1; then
    printf '%s\n' "jq is required for API calls."
    return 1
  fi

  curl -s https://api.openai.com/v1/chat/completions \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $OPENAI_API_KEY" \
    -d "{\n      \"model\": \"$ENGINE_MODEL\",\n      \"messages\": [\n        {\"role\": \"system\", \"content\": $(printf '%s' "$system_prompt" | jq -Rs .)},\n        {\"role\": \"user\", \"content\": $(printf '%s' "$user_message" | jq -Rs .)}\n      ]\n    }" | jq -r '.choices[0].message.content'
}

execute_request() {
  local request="$1"
  local response
  local status

  activate_agents "$request"
  show_agent_status

  set +e
  case "$ACTIVE_ENGINE" in
    claude)
      if [[ -n "$ENGINE_MODEL" ]]; then
        response=$(printf '%s\n' "$request" | claude --print --system-prompt "$SYSTEM_PROMPT" --model "$ENGINE_MODEL" 2>&1)
      else
        response=$(printf '%s\n' "$request" | claude --print --system-prompt "$SYSTEM_PROMPT" 2>&1)
      fi
      status=$?
      ;;
    codex)
      if [[ -n "$ENGINE_MODEL" ]]; then
        response=$(codex --full-auto --quiet -m "$ENGINE_MODEL" "$request" 2>&1)
      else
        response=$(codex --full-auto --quiet "$request" 2>&1)
      fi
      status=$?
      ;;
    anthropic-api)
      response=$(call_anthropic_api "$SYSTEM_PROMPT" "$request" 2>&1)
      status=$?
      ;;
    openai-api)
      response=$(call_openai_api "$SYSTEM_PROMPT" "$request" 2>&1)
      status=$?
      ;;
    *)
      response="No engine selected."
      status=1
      ;;
  esac
  set -e

  if (( status != 0 )); then
    show_engine_error "$response"
    reset_agent_status
    return 1
  fi

  response=$(filter_response "$response")
  printf '\n'
  printf '%b\n' "${WHT}${response}${RST}"
  printf '\n'

  reset_agent_status
}

show_help() {
  printf '%b\n' "${WHT}Commands:${RST}"
  printf '%b\n' "  help      Show available commands"
  printf '%b\n' "  status    Show all agents"
  printf '%b\n' "  teams     Show team overview"
  printf '%b\n' "  engine    Show active engine"
  printf '%b\n' "  config    Show configuration"
  printf '%b\n' "  clear     Clear screen and redraw banner"
  printf '%b\n' "  exit      Exit HIVEMIND"
  printf '\n'
  printf '%b\n' "${WHT}CLI:${RST}"
  printf '%b\n' "  hivemind \"request\"           Execute single request and exit"
  printf '%b\n' "  hivemind --engine claude      Use specific engine"
  printf '%b\n' "  hivemind --model gpt-4o        Use specific model"
  printf '%b\n' "  hivemind --status             Show status and exit"
  printf '%b\n' "  hivemind --help               Show help"
  printf '%b\n' "  hivemind --version            Show version"
}

show_teams() {
  printf '%b\n' "${WHT}Teams:${RST}"
  printf '%b\n' "  DEV  Development"
  printf '%b\n' "  SEC  Security"
  printf '%b\n' "  INF  Infrastructure"
  printf '%b\n' "  QA   Quality Assurance"
}

show_config() {
  printf '%b\n' "${WHT}Configuration:${RST}"
  printf '%b\n' "  Config file: $CONFIG_FILE"
  printf '%b\n' "  Colors:      ${COLOR_ENABLED}"
  printf '%b\n' "  Compact:     ${COMPACT_MODE}"
  printf '%b\n' "  Engine:      ${ACTIVE_ENGINE:-none}"
  printf '%b\n' "  Model:       ${ENGINE_MODEL:-default}"
}

show_setup() {
  printf '%b\n' "${WHT}Setup:${RST}"
  printf '%b\n' "  Install Claude Code CLI: npm install -g @anthropic-ai/claude-code"
  printf '%b\n' "  Install OpenAI Codex:    pip install openai-codex"
  printf '%b\n' "  Set API keys:            export ANTHROPIC_API_KEY=..."
  printf '%b\n' "                          export OPENAI_API_KEY=..."
}

handle_command() {
  local cmd="$1"
  case "$cmd" in
    help)
      show_help
      return 0
      ;;
    status)
      show_all_agents
      return 0
      ;;
    teams)
      show_teams
      return 0
      ;;
    engine)
      show_engine_info
      return 0
      ;;
    config)
      show_config
      return 0
      ;;
    clear)
      show_banner
      return 0
      ;;
    exit|quit)
      exit 0
      ;;
    *)
      return 1
      ;;
  esac
}

init_history() {
  mkdir -p "$CONFIG_DIR"
  touch "$HISTORY_FILE"
  HISTFILE="$HISTORY_FILE"
  HISTSIZE=2000
  HISTFILESIZE=2000
  history -r "$HISTORY_FILE" 2>/dev/null || true
}

run_interactive() {
  init_history

  shopt -s histappend 2>/dev/null || true

  printf '%b\n' "${WHT}HIVEMIND ready.${RST} All teams standing by."

  while true; do
    local input
    if [[ -t 0 ]]; then
      if ! read -er -p "HIVEMIND> " input; then
        printf '\n'
        break
      fi
    else
      if ! read -r input; then
        printf '\n'
        break
      fi
    fi
    if [[ -z "${input:-}" ]]; then
      continue
    fi
    input="${input#"${input%%[![:space:]]*}"}"
    if [[ -z "$input" ]]; then
      continue
    fi

    history -s "$input" 2>/dev/null || true
    history -a 2>/dev/null || true

    if handle_command "$input"; then
      continue
    fi

    execute_request "$input" || true
  done
}

run_single_request() {
  local request="$1"
  execute_request "$request"
}

main() {
  load_config
  init_colors
  init_agents

  local show_help_flag=false
  local show_version_flag=false
  local show_status_flag=false
  local show_setup_flag=false
  local show_config_flag=false
  local args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        show_help_flag=true
        shift
        ;;
      --version)
        show_version_flag=true
        shift
        ;;
      --status)
        show_status_flag=true
        shift
        ;;
      --setup)
        show_setup_flag=true
        shift
        ;;
      --config)
        show_config_flag=true
        shift
        ;;
      --engine)
        ENGINE_OVERRIDE="${2:-}"
        shift 2
        ;;
      --model)
        MODEL_OVERRIDE="${2:-}"
        shift 2
        ;;
      --)
        shift
        args+=("$@")
        break
        ;;
      -* )
        printf '%s\n' "Unknown option: $1"
        exit 1
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done

  if [[ "$show_help_flag" == "true" ]]; then
    show_help
    return 0
  fi

  if [[ "$show_version_flag" == "true" ]]; then
    printf '%s\n' "$VERSION"
    return 0
  fi

  show_banner

  if [[ "$show_setup_flag" == "true" ]]; then
    show_setup
    return 0
  fi

  if [[ "$show_config_flag" == "true" ]]; then
    printf '%s\n' "HIVEMIND Configuration"
    printf '%s\n' "======================"
    printf '%s\n' "Config dir: $CONFIG_DIR"
    printf '%s\n' "Config file: $CONFIG_FILE"
    if [[ -f "$CONFIG_FILE" ]]; then
      cat "$CONFIG_FILE"
    else
      printf '%s\n' "(no config file found - using defaults)"
    fi
    return 0
  fi

  detect_engine
  ENGINE_MODEL=$(resolve_engine_model)

  if [[ -z "$ACTIVE_ENGINE" ]]; then
    show_no_engine
    exit 1
  fi

  show_engine_info

  if [[ "$show_status_flag" == "true" ]]; then
    show_all_agents
    return 0
  fi

  if ((${#args[@]} > 0)); then
    local request
    request=$(printf '%s ' "${args[@]}")
    request="${request% }"
    run_single_request "$request"
  else
    run_interactive
  fi
}

main "$@"
